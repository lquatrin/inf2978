import timeimport mathimport randomimport bwreadersimport bwdistanceimport bwnumbergenimport bwserializationimport bwprojectionimport bwmathimport numpy as npimport osimport gcDOCWORD_FILE = "../docword.nytimes.txt"VOCAB_FILE = "vocab.nytimes.txt"# 1 2# 1. Baixe o dataset Bag of Words da UCI (arquivo NyTimes). Cerca de 300k docs e vocabulario com 102650 termos# 2. Crie uma bag of words para os 3000 primeiros documentosword_list = bwreaders.ReadVocabulary(VOCAB_FILE)D_t_work = 3000table_docs = bwreaders.ReadDocuments(DOCWORD_FILE, D_t_work)#documents =  bwreaders.read_document_corpus(filepath= './docword.nytimes.txt_preprocessed.txt',#                                              num_docs=3000,#                                              num_words_in_vocabulary=102650)documents = table_docs[0]# n documentosD = table_docs[1]# n palavrasW = table_docs[2]# n entradasNNZ = table_docs[3]# 3# 3. Calcule a distancia entre cada par de pontos atraves da forca bruta e messa o tempo computacional deste procedimento. Armazene estes valores. Utilize dois loops para fazer isso e implemente o calculo da distanciamtx_original_distance = bwdistance.GenerateOriginalDistanceMatrix(D_t_work, W, documents)# 4# 4. Para n = 4, 16, 64, 256, 1024, 4096, 15768, repita o procedimento abaixo 30 vezesrepeat = 1#30n_cases = [ 4, 16, 64, 256, 1024, 4096, 15768 ]# 4.1. Obtenha uma matriz aleatoria de n linhas e d colunas pelo metodo de Achiloptas e pelo metodo dado em aula, onde d e o tamanho do vocaulario.# 4.2. Messa o tempo computacional da geracao das matrizes# 4.3. Projete os 3000 documentos no espaco Rn atraves das matrizes geradas. Messa o tempo da projecao# TODO# MATRIX_n_d * VETOR_d_1 = VERTO_n_1# 4.4. Messa o tempo para obter todas as distancias entre os pontos projetados# 4.5. Calcule a distors˜ao maxima em relacao aos dados originais.# Achiloptas# 4.6. Calcule o limite superior da distorsao previsto pelo Lema de J.L.##################################################################### Versão 1:# - Geração da matriz # - Projeção (maior consumo de memória)#####################################################################matrizes com os tempos:# . número de casos (7)# . número de repetições (30)# . número de operações x2#   1. matriz achiloptas#   2. projeção achiloptas#   3. tempo para obter novas distâncias#########################################   4. matriz random proj#   5. projeção random proj#   6. tempo para obter novas distânciasv1_timers = np.zeros(shape = (6))v1_distortions = np.zeros(shape = (2, 3)) # mean, min, maxfor x in range(2):  v1_distortions[x][1] = float('inf')  v1_distortions[x][2] = -float('inf')ith_case = 0n_cases2 = [ 4096 ]for N in n_cases2:  n = N  d = W  # se N for maior que 1024  if N > 1024:    break  print("Case: ", N)  for ith_repeat in range(repeat):    projected_documents = None    Proj_DistanceMatrix = None    projection_matrix = None    # Achiloptas    ##################################################################################    #print(N, ith_repeat, "Achiloptas")    # 4.1 4.2    s_clock = time.clock()    projection_matrix = bwnumbergen.GenerateRandomAchiloptasMatrix(n,d)    f_clock = time.clock()    v1_timers[0] += (f_clock - s_clock)    # 4.3    s_clock = time.clock()    projected_documents = bwprojection.ProjectDocuments(documents, projection_matrix, n, D_t_work)    projected_documents = projected_documents * math.sqrt(3/n)    f_clock = time.clock()    v1_timers[1] += (f_clock - s_clock)    # 4.4    s_clock = time.clock()    Proj_DistanceMatrix = bwdistance.DoEuclidianDistanceProjDocs(projected_documents)    f_clock = time.clock()    v1_timers[2] += (f_clock - s_clock)    # 4.5    max_distortion = bwmath.MaxDistortion(mtx_original_distance, Proj_DistanceMatrix)    v1_distortions[0][0] += max_distortion    v1_distortions[0][1] = min(max_distortion, v1_distortions[0][1])    v1_distortions[0][2] = max(max_distortion, v1_distortions[0][2])    ##################################################################################        projected_documents = None    Proj_DistanceMatrix = None    projection_matrix = None    # Random projections with gaussian    ##################################################################################    #print(N, ith_repeat, "Random Projection")    # 4.1 4.2    s_clock = time.clock()    projection_matrix = bwnumbergen.GenerateRandomGaussianMatrix(n,d)    f_clock = time.clock()    v1_timers[3] += (f_clock - s_clock)    # 4.3    s_clock = time.clock()    projected_documents = bwprojection.ProjectDocuments(documents, projection_matrix, n, D_t_work)    f_clock = time.clock()    v1_timers[4] += (f_clock - s_clock)    # 4.4    s_clock = time.clock()    Proj_DistanceMatrix = bwdistance.DoEuclidianDistanceProjDocs(projected_documents)    f_clock = time.clock()    v1_timers[5] += (f_clock - s_clock)        # 4.5    max_distortion = bwmath.MaxDistortion(mtx_original_distance, Proj_DistanceMatrix)    v1_distortions[1][0] += max_distortion    v1_distortions[1][1] = min(max_distortion, v1_distortions[1][1])    v1_distortions[1][2] = max(max_distortion, v1_distortions[1][2])    ##################################################################################  for x in range(6):    v1_timers[x] = v1_timers[x] / (60.0 * float(repeat))  v1_distortions[0][0] = v1_distortions[0][0] / float(repeat)  v1_distortions[1][0] = v1_distortions[1][0] / float(repeat)   # 4.6  v1_JL = bwmath.CalculateJLLema(d, n)  print('Achiloptas')  print(v1_timers[0])  print(v1_timers[1])  print(v1_timers[2])  print(v1_distortions[0][0])  print(v1_distortions[0][1])  print(v1_distortions[0][2])  print('Random Projection')  print(v1_timers[3])  print(v1_timers[4])  print(v1_timers[5])  print(v1_distortions[1][0])  print(v1_distortions[1][1])  print(v1_distortions[1][2])  print('JL Lema')  print(v1_JL)  ith_case = ith_case + 1##################################################################### Versão 2:# - Geração e projeção ao mesmo tempo (menor consumo de memória)#####################################################################matrizes com os tempos:# . número de casos (7)# . número de repetições (30)# . número de operações x2#   1. matriz e projeção achiloptas#   2. tempo para obter novas distâncias#########################################   3. matriz e projeção random proj#   4. tempo para obter novas distânciasv2_timers = np.zeros(shape = (4))v2_distortions = np.zeros(shape = (2, 3)) # mean, min, maxfor x in range(2):  v2_distortions[x][1] = float('inf')  v2_distortions[x][2] = -float('inf')ith_case = 0for N in n_cases:  n = N  d = W  print("Case: ", N)  for ith_repeat in range(repeat):    projected_documents = None    Proj_DistanceMatrix = None    # Achiloptas    ##################################################################################    #print(N, ith_repeat, "Achiloptas")    # 4.1 4.2 4.3    s_clock = time.clock()    projected_documents = bwprojection.GenerateAndProjectDocumentsAchiloptas(documents, n, D_t_work, d)    projected_documents = projected_documents * math.sqrt(3/n)    f_clock = time.clock()    v2_timers[0] += (f_clock - s_clock)    # 4.4    s_clock = time.clock()    Proj_DistanceMatrix = bwdistance.DoEuclidianDistanceProjDocs(projected_documents)    f_clock = time.clock()    v2_timers[1] += (f_clock - s_clock)    # 4.5    max_distortion = bwmath.MaxDistortion(mtx_original_distance, Proj_DistanceMatrix)    v2_distortions[0][0] += max_distortion    v2_distortions[0][1] = min(max_distortion, v2_distortions[0][1])    v2_distortions[0][2] = max(max_distortion, v2_distortions[0][2])    ##################################################################################        projected_documents = None    Proj_DistanceMatrix = None    # Random projections with gaussian    ##################################################################################    #print(N, ith_repeat, "Random Projection")    # 4.1 4.2 4.3    s_clock = time.clock()    projected_documents = bwprojection.GenerateAndProjectDocumentsRandomGeneration(documents, n, D_t_work, d)    f_clock = time.clock()    v2_timers[2] += (f_clock - s_clock)    # 4.4    s_clock = time.clock()    Proj_DistanceMatrix = bwdistance.DoEuclidianDistanceProjDocs(projected_documents)    f_clock = time.clock()    v2_timers[3] += (f_clock - s_clock)        # 4.5    max_distortion = bwmath.MaxDistortion(mtx_original_distance, Proj_DistanceMatrix)    v2_distortions[1][0] += max_distortion    v2_distortions[1][1] = min(max_distortion, v2_distortions[1][1])    v2_distortions[1][2] = max(max_distortion, v2_distortions[1][2])    ##################################################################################  for x in range(4):    v2_timers[x] = v2_timers[x] / (60.0 * float(repeat))  v2_distortions[0][0] = v2_distortions[0][0] / float(repeat)  v2_distortions[1][0] = v2_distortions[1][0] / float(repeat)  # 4.6  v2_JL = bwmath.CalculateJLLema(d, n)  print('Achiloptas')  print(v2_timers[0])  print(v2_timers[1])  print(v2_distortions[0][0])  print(v2_distortions[0][1])  print(v2_distortions[0][2])  print('Random Projection')  print(v2_timers[2])  print(v2_timers[3])  print(v2_distortions[1][0])  print(v2_distortions[1][1])  print(v2_distortions[1][2])  print('JL Lema')  print(v2_JL)  ith_case = ith_case + 1