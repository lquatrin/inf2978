import timeimport mathimport randomimport bwreadersimport bwdistanceimport bwnumbergenimport bwserializationimport bwprojectionimport numpy as npimport osimport gc#import matUtils# id's considered to start by 1DOCWORD_FILE = "../docword.nytimes.txt"VOCAB_FILE = "vocab.nytimes.txt"# 1 2# 1. Baixe o dataset Bag of Words da UCI (arquivo NyTimes). Cerca de 300k docs e vocabulario com 102650 termos# 2. Crie uma bag of words para os 3000 primeiros documentosword_list = bwreaders.ReadVocabulary(VOCAB_FILE)D_t_work = 3000table_docs = bwreaders.ReadDocuments(DOCWORD_FILE, D_t_work)#documents =  bwreaders.read_document_corpus(filepath= './docword.nytimes.txt_preprocessed.txt',#                                              num_docs=3000,#                                              num_words_in_vocabulary=102650)documents = table_docs[0]D = table_docs[1]W = table_docs[2]NNZ = table_docs[3]# 3# 3. Calcule a distancia entre cada par de pontos atraves da forca bruta e messa o tempo computacional deste procedimento. Armazene estes valores. Utilize dois loops para fazer isso e implemente o calculo da distanciaDistanceMatrix = bwserialization.LoadPickleObject('distance_matrix')if DistanceMatrix == None:  DistanceMatrix = [[0 for x in range(D_t_work)] for y in range(D_t_work)]  start_clock = time.clock()  for x in range(0, D_t_work):    print(x)    DistanceMatrix[x][x] = 0.0    for y in range(x + 1, D_t_work):      DistanceMatrix[x][y] = bwdistance.DocEuclidianDistance(x, y, documents, W)      # TODO: remove this      DistanceMatrix[y][x] = DistanceMatrix[x][y]  finish_clock = time.clock()  bwserialization.SavePickleObject('distance_matrix', DistanceMatrix)  print(finish_clock - start_clock)# 4# 4. Para n = 4, 16, 64, 256, 1024, 4096, 15768, repita o procedimento abaixo 30 vezesline_generation = Falserepeat = 1 #30n_cases = [ 4, 16, 64, 256, 1024, 4096, 15768 ]for N in n_cases:  n = N  d = W  for cases in range(repeat):    # 4.1. Obtenha uma matriz aleatoria de n linhas e d colunas pelo metodo de Achiloptas e pelo metodo dado em aula, onde d e o tamanho do vocaulario.    # 4.2. Messa o tempo computacional da geracao das matrizes    # 4.3. Projete os 3000 documentos no espaco Rn atraves das matrizes geradas. Messa o tempo da projecao    # TODO    # MATRIX_n_d * VETOR_d_1 = VERTO_n_1    # 4.4. Messa o tempo para obter todas as distancias entre os pontos projetados        # 4.1 4.2 4.3 4.4 - Achiloptas    ##################################################################################    ach_proj_m = None    if line_generation:      print(n, D_t_work, d)      ach_proj_m = bwprojection.GenerateAndProjectDocumentsAchiloptas(documents, n, D_t_work, d)      ach_proj_m = ach_proj_m * math.sqrt(3/n)    else:      #TIME_CLOCK      achiloptas_s = time.clock()      A_Matrix = np.zeros(shape = (n,d))      for i in range(n):        for j in range(d):          A_Matrix[i][j] = bwnumbergen.RandomGenAchiloptasValue(random.random())      #TIME_CLOCK      achiloptas_f = time.clock()      achiloptas_Proj_start = time.clock()      ach_proj_m = bwprojection.ProjectDocuments(documents, A_Matrix, n, D_t_work)      ach_proj_m = ach_proj_m * math.sqrt(3/n)      achiloptas_Proj_end = time.clock()         #ach_dist_start_clock = time.clock()    #Ach_DistanceMatrix = matUtils.distance_matrix(ProjMatAch)    #ach_dist_finish_clock = time.clock()    ##################################################################################        # 4.1 4.2 4.3 4.4 - Random projections with gaussian    ##################################################################################    ProjMatRN = None    if line_generation:      ProjMatRN = bwprojection.GenerateAndProjectDocumentsRandomGeneration(documents, n, D_t_work, d)    else:      #TIME_CLOCK      random_s = time.clock()      R_Matrix = np.zeros(shape = (n,d))      s_dev = math.sqrt(1/n)      for i in range(n):        for j in range(d):          R_Matrix[i][j] = bwnumbergen.RandomGenGaussianValue(random.random(), 0, s_dev)      #TIME_CLOCK      random_f = time.clock()           Random_Proj_start = time.clock()      ProjMatRN = bwprojection.ProjectDocuments(documents, R_Matrix, n, D_t_work)      Random_Proj_end = time.clock()    #rn_dist_start_clock = time.clock()    #RN_DistanceMatrix = matUtils.distance_matrix(ProjMatRN)    #rn_dist_finish_clock = time.clock()    ##################################################################################    print(n, d, achiloptas_f - achiloptas_s, random_f - random_s)   	    # 4.5. Calcule a distors˜ao maxima em relacao aos dados originais.    # Achiloptas    #distortionAch = matUtils.maxDistortion(DistanceMatrix,ProjMatAch)    # Random projections    #distortionRN = matUtils.maxDistortion(DistanceMatrix,ProjMatRN)    # 4.6. Calcule o limite superior da distorsao previsto pelo Lema de J.L.    #JL = calculateJLLema(W,n)# 5. Escreva um relatorio descrevendo os experimentos e os resultados obtidos. Analise se os resultados obtidos estao de acordo com a teoria apresentada. Considere a media, o maximo e o mınimo dos 30 experimentos do item 4.# TODO